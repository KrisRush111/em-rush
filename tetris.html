<!DOCTYPE html>
<html lang="ru">
<head>
     <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
    <title>Тетрис | Drag & Drop Style</title>
    <script src="tailwind.js"></script>
      <link rel="stylesheet" href="fontawesome-free-6.7.2-web/css/all.min.css">
      <script src="https://telegram.org/js/telegram-web-app.js"></script>
<script src="theme.js"></script>

    <style>
          html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    width: 100%;

  }
       body {
            background-color: #111827;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Изменено для прокрутки */
            overflow-x: hidden;
            touch-action: manipulation;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            position: relative;
            padding-top: 80px;
            padding-bottom: 80px; /* Добавлено для прокрутки */
            -webkit-user-select: none; /* Запрет выделения для Safari */
            -moz-user-select: none; /* Запрет выделения для Firefox */
            -ms-user-select: none; /* Запрет выделения для IE/Edge */
            user-select: none; /* Запрет выделения */
        }
        
          /* Защита от копирования */
        body {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            touch-action: manipulation;
        }
        
        /* Защита от контекстного меню */
        body {
            pointer-events: auto;
        }
        
        .back-arrow {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            cursor: pointer;
            z-index: 100;
            transition: transform 0.2s;
        }
        
        .back-arrow:hover {
            transform: translateX(-3px);
        }
        
        .confirmation-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        
        .confirmation-modal.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .confirmation-content {
            background-color: #1f2937;
            padding: 25px;
            border-radius: 12px;
            max-width: 300px;
            width: 90%;
            text-align: center;
            border: 1px solid rgba(99, 102, 241, 0.5);
            box-shadow: 0 0 20px rgba(99, 102, 241, 0.3);
        }
        
        .confirmation-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }
        
        .confirmation-btn {
            padding: 8px 20px;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, opacity 0.2s;
        }
        
        .confirmation-btn:hover {
            transform: translateY(-2px);
        }
        
        .confirmation-btn:active {
            transform: translateY(0);
        }
        
        .btn-yes {
            background-color: #ef4444;
            color: white;
        }
        
        .btn-no {
            background-color: #3b82f6;
            color: white;
        }

        @keyframes fadeIn {
            0% {
                opacity: 0;
                transform: 
                    translateY(50px) 
                    scale(0.8) 
                    rotateX(60deg) 
                    perspective(500px);
                filter: blur(5px);
                box-shadow: 0 0 100px rgba(99, 102, 241, 0.8);
            }
            60% {
                opacity: 0.8;
                transform: 
                    translateY(-15px) 
                    scale(1.05) 
                    rotateX(20deg);
                filter: blur(1px);
            }
            80% {
                transform: 
                    translateY(5px) 
                    scale(0.98) 
                    rotateX(0);
            }
            100% {
                opacity: 1;
                transform: 
                    translateY(0) 
                    scale(1) 
                    rotateX(0);
                filter: blur(0);
                box-shadow: 0 0 30px rgba(99, 102, 241, 0.3);
            }
        }

        .game-container {
            background: rgba(17, 24, 39, 0.8);
            border-radius: 16px;
            box-shadow: 0 0 30px rgba(99, 102, 241, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(99, 102, 241, 0.3);
            animation: 
                fadeIn 1.2s cubic-bezier(0.2, 0.8, 0.2, 1) both,
                pulse 3s ease-in-out infinite 1.5s;
            transform-style: preserve-3d;
            perspective: 1000px;
            
            /* Отключаем анимацию при повторах */
            &:not(.initial-load) {
                animation: pulse 3s ease-in-out infinite;
            }
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 95%;
        }

        .game-board {
            border: 2px solid rgba(99, 102, 241, 0.5);
            border-radius: 8px;
            background-color: rgba(31, 41, 55, 0.7);
            box-shadow: 0 0 20px rgba(99, 102, 241, 0.2);
            position: relative;
            overflow: hidden;
            touch-action: none;
        }

        .block {
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-sizing: border-box;
            position: absolute;
            border-radius: 4px;
            transition: transform 0.1s, opacity 0.3s;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2);
            cursor: move;
            user-select: none;
            touch-action: none;
        }

        /* Разноцветные блоки с градиентами и свечением */
        .block.I-1 { background: linear-gradient(135deg, #00f5d4, #00bbf9); box-shadow: inset 0 0 10px rgba(0,0,0,0.2), 0 0 10px rgba(0, 245, 212, 0.5); }
        .block.I-2 { background: linear-gradient(135deg, #00e5ff, #0088ff); box-shadow: inset 0 0 10px rgba(0,0,0,0.2), 0 0 10px rgba(0, 229, 255, 0.5); }
        .block.I-3 { background: linear-gradient(135deg, #00c9ff, #0095ff); box-shadow: inset 0 0 10px rgba(0,0,0,0.2), 0 0 10px rgba(0, 201, 255, 0.5); }

        .block.J-1 { background: linear-gradient(135deg, #8338ec, #3a86ff); box-shadow: inset 0 0 10px rgba(0,0,0,0.2), 0 0 10px rgba(131, 56, 236, 0.5); }
        .block.J-2 { background: linear-gradient(135deg, #7209b7, #4361ee); box-shadow: inset 0 0 10px rgba(0,0,0,0.2), 0 0 10px rgba(114, 9, 183, 0.5); }
        .block.J-3 { background: linear-gradient(135deg, #560bad, #4895ef); box-shadow: inset 0 0 10px rgba(0,0,0,0.2), 0 0 10px rgba(86, 11, 173, 0.5); }

        .block.L-1 { background: linear-gradient(135deg, #ff9e00, #ff5400); box-shadow: inset 0 0 10px rgba(0,0,0,0.2), 0 0 10px rgba(255, 158, 0, 0.5); }
        .block.L-2 { background: linear-gradient(135deg, #ff9500, #ff3e00); box-shadow: inset 0 0 10px rgba(0,0,0,0.2), 0 0 10px rgba(255, 149, 0, 0.5); }
        .block.L-3 { background: linear-gradient(135deg, #ff8500, #ff2d00); box-shadow: inset 0 0 10px rgba(0,0,0,0.2), 0 0 10px rgba(255, 133, 0, 0.5); }

        .block.O-1 { background: linear-gradient(135deg, #38b000, #70e000); box-shadow: inset 0 0 10px rgba(0,0,0,0.2), 0 0 10px rgba(56, 176, 0, 0.5); }
        .block.O-2 { background: linear-gradient(135deg, #2b9348, #80b918); box-shadow: inset 0 0 10px rgba(0,0,0,0.2), 0 0 10px rgba(43, 147, 72, 0.5); }
        .block.O-3 { background: linear-gradient(135deg, #1b9e2e, #55a630); box-shadow: inset 0 0 10px rgba(0,0,0,0.2), 0 0 10px rgba(27, 158, 46, 0.5); }

        .block.S-1 { background: linear-gradient(135deg, #ff006e, #ff7096); box-shadow: inset 0 0 10px rgba(0,0,0,0.2), 0 0 10px rgba(255, 0, 110, 0.5); }
        .block.S-2 { background: linear-gradient(135deg, #e63946, #ff758f); box-shadow: inset 0 0 10px rgba(0,0,0,0.2), 0 0 10px rgba(230, 57, 70, 0.5); }
        .block.S-3 { background: linear-gradient(135deg, #d00000, #ff5a5f); box-shadow: inset 0 0 10px rgba(0,0,0,0.2), 0 0 10px rgba(208, 0, 0, 0.5); }

        .block.T-1 { background: linear-gradient(135deg, #9b5de5, #f15bb5); box-shadow: inset 0 0 10px rgba(0,0,0,0.2), 0 0 10px rgba(155, 93, 229, 0.5); }
        .block.T-2 { background: linear-gradient(135deg, #7b2cbf, #c77dff); box-shadow: inset 0 0 10px rgba(0,0,0,0.2), 0 0 10px rgba(123, 44, 191, 0.5); }
        .block.T-3 { background: linear-gradient(135deg, #5a189a, #e0aaff); box-shadow: inset 0 0 10px rgba(0,0,0,0.2), 0 0 10px rgba(90, 24, 154, 0.5); }

        .block.Z-1 { background: linear-gradient(135deg, #ef233c, #d90429); box-shadow: inset 0 0 10px rgba(0,0,0,0.2), 0 0 10px rgba(239, 35, 60, 0.5); }
        .block.Z-2 { background: linear-gradient(135deg, #d00000, #9d0208); box-shadow: inset 0 0 10px rgba(0,0,0,0.2), 0 0 10px rgba(208, 0, 0, 0.5); }
        .block.Z-3 { background: linear-gradient(135deg, #b7094c, #a01a58); box-shadow: inset 0 0 10px rgba(0,0,0,0.2), 0 0 10px rgba(183, 9, 76, 0.5); }

        /* Сетка игрового поля */
        .grid-cell {
            position: absolute;
            border: 1px solid rgba(255, 255, 255, 0.05);
            box-sizing: border-box;
        }

        .score-box {
            background-color: rgba(31, 41, 55, 0.7);
            border: 2px solid rgba(99, 102, 241, 0.5);
            border-radius: 8px;
            padding: 10px 20px;
            text-align: center;
            margin-bottom: 15px;
            width: 100%;
            max-width: 300px;
        }

        .preview-container {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-top: 20px;
            gap: 10px;
        }

        .preview-piece {
            background-color: rgba(31, 41, 55, 0.7);
            border: 2px solid rgba(99, 102, 241, 0.5);
            border-radius: 8px;
            position: relative;
            flex: 1;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: grab;
            transition: transform 0.2s, box-shadow 0.2s;
            overflow: hidden;
            touch-action: none;
        }

        .preview-piece:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(99, 102, 241, 0.4);
        }

        .preview-piece:active {
            cursor: grabbing;
        }

        .preview-piece.empty {
            background-color: rgba(31, 41, 55, 0.3);
            border: 2px dashed rgba(99, 102, 241, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .preview-piece.empty::after {
            content: "+";
            color: rgba(255, 255, 255, 0.3);
            font-size: 24px;
            font-weight: bold;
        }

        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(17, 24, 39, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            border-radius: 16px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .game-over.show {
            opacity: 1;
            pointer-events: all;
        }

        .restart-btn {
            background: linear-gradient(135deg, #8338ec, #3a86ff);
            border: none;
            border-radius: 50px;
            padding: 12px 30px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 4px 15px rgba(131, 56, 236, 0.5);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .restart-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(131, 56, 236, 0.6);
        }

        .restart-btn:active {
            transform: translateY(0);
            box-shadow: 0 4px 15px rgba(131, 56, 236, 0.5);
        }

        .line-clear {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 3px;
            animation: lineClear 0.3s forwards;
            z-index: 5;
        }

        @keyframes lineClear {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.05); }
            100% { opacity: 0; transform: scale(0.5); }
        }

        .dragging {
            opacity: 0.8;
            transform: scale(1.05);
            z-index: 100;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.7) !important;
        }

        .instructions {
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            text-align: center;
            margin-top: 15px;
            max-width: 300px;
        }

        .rotate-btn {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 5;
            transition: all 0.2s;
        }

        .rotate-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: rotate(90deg);
        }

        /* Плавное появление новых блоков с "подлетом" */
        .block.new-block {
            animation: blockDropIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }

        @keyframes blockDropIn {
            0% {
                transform: translateY(-30px);
                opacity: 0.8;
            }
            100% {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* Анимация наложения/приземления блока */
        .block.landing {
            animation: blockLanding 0.6s cubic-bezier(0.68, -0.6, 0.32, 1.6) forwards;
        }

        @keyframes blockLanding {
            0% {
                transform: scale(1.2);
                box-shadow: 0 0 15px rgba(255,255,255,0.5);
            }
            100% {
                transform: scale(1);
                box-shadow: none;
            }
        }
        
        /* Анимации при проигрыше */
        @keyframes blockCorrupt {
            0% { filter: brightness(1) hue-rotate(0deg); opacity: 1; }
            30% { filter: brightness(1.5) hue-rotate(45deg); transform: scale(1.1); }
            70% { filter: brightness(0.7) hue-rotate(90deg); }
            100% { filter: brightness(0.4) hue-rotate(180deg); opacity: 0.7; transform: scale(0.95); }
        }
        
        @keyframes blockFall {
            0% { transform: translateY(0); }
            100% { transform: translateY(calc(100vh)); }
        }
        
        .block.corrupted {
            animation: blockCorrupt 0.8s ease forwards, blockFall 1s ease-in 0.2s forwards;
            z-index: 20;
        }
        
        @keyframes gameOverShow {
            0% { opacity: 0; transform: scale(0.8) translateY(50px); }
            100% { opacity: 1; transform: scale(1) translateY(0); }
        }
        
        .game-over.show {
            opacity: 1;
            pointer-events: all;
            animation: gameOverShow 0.6s cubic-bezier(0.4, 0, 0.2, 1) 0.8s both;
        }

        /* Эффект при наведении на превью */
        .preview-piece:not(.empty):hover .block {
            filter: brightness(1.2);
            transform: scale(1.05);
        }

   
       
        #drag-visual {
    position: fixed;
    pointer-events: none;
    z-index: 1000;
    touch-action: none;

    /* Смещаем левее на 20px и поднимаем по Y */
    transform: translate(calc(-50% - 30px), 0);
    transform-origin: center top;
    margin-top: -100px;
}




        /* Эффект при перетаскивании */
        .preview-piece.dragging-source {
            opacity: 0.4;
            transform: scale(0.95);
        }

       /* Подсветка при наведении - теперь на уровне с фигурой */
       .hover-highlight {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            z-index: 5; /* Выше других элементов */
            pointer-events: none;
            margin-top: -100px; /* Смещаем вверх, как и drag-visual */
        }
        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.1; }
        }
        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 0 30px rgba(99, 102, 241, 0.3);
                transform: scale(1) translateY(0);
            }
            50% {
                box-shadow: 0 0 50px rgba(99, 102, 241, 0.5);
                transform: scale(1.01) translateY(-3px);
            }
        }
    </style>
</head>
<body>
    <!-- Белая стрелка для возврата -->
    <div class="back-arrow" id="backArrow">
        <i class="fas fa-arrow-left"></i>
    </div>
    
    <!-- Модальное окно подтверждения -->
    <div class="confirmation-modal" id="confirmationModal">
        <div class="confirmation-content">
            <h3 class="text-xl font-bold text-white mb-4">Вы точно хотите покинуть игру?</h3>
            <p class="text-gray-300 mb-6">На ваш счет пойдут только те RCC, что вы собрали за это время</p>
            <div class="confirmation-buttons">
                <button class="confirmation-btn btn-yes" id="confirmYes">Да</button>
                <button class="confirmation-btn btn-no" id="confirmNo">Нет</button>
            </div>
        </div>
    </div>

    <div class="game-container">
        <h1 class="text-3xl font-bold mb-4 text-white">
            <i class="fas fa-cubes text-blue-400 mr-2"></i>
            <span class="bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-500">Тетрис Drag & Drop</span>
        </h1>

        <div class="score-box">
            <div class="text-blue-300 text-sm">RCC</div>
            <div class="text-2xl font-bold text-white" id="score">0</div>
        </div>

        <div id="game-board" class="game-board" style="width: 300px; height: 300px;"></div>

    

        <div class="preview-container">
            <div class="preview-piece" id="preview-1"></div>
            <div class="preview-piece" id="preview-2"></div>
            <div class="preview-piece" id="preview-3"></div>
        </div>

        <div class="game-over" id="game-over">
            <h2 class="text-4xl font-bold text-blue-400 mb-4">Игра окончена!</h2>
            <p class="text-xl mb-6 text-white">Ваш счет RCC: <span id="final-score">0</span></p>
            <button class="restart-btn" id="restart-btn">
                <i class="fas fa-play mr-2"></i> Играть снова
            </button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Элементы для возврата
            const backArrow = document.getElementById('backArrow');
            const confirmationModal = document.getElementById('confirmationModal');
            const confirmYes = document.getElementById('confirmYes');
            const confirmNo = document.getElementById('confirmNo');
            
            // Обработчики для кнопки возврата
            backArrow.addEventListener('click', function() {
                // Если игра завершена, сразу переходим без подтверждения
                if (gameOver) {
                    saveScoreAndRedirect();
                } else {
                    // Иначе показываем предупреждение
                    confirmationModal.classList.add('active');
                }
            });
            
            confirmYes.addEventListener('click', function() {
                saveScoreAndRedirect();
            });
            
            confirmNo.addEventListener('click', function() {
                confirmationModal.classList.remove('active');
            });

            // Функция для сохранения счета и перенаправления
            function saveScoreAndRedirect() {
                // Получаем текущий счет
                const currentScore = parseInt(scoreElement.textContent);
                
                // Получаем сохраненные данные из localStorage
                const savedData = JSON.parse(localStorage.getItem('raccoonClickerShared') || '{}');
                
                // Добавляем текущий счет к общему количеству RCC
                savedData.coins = (savedData.coins || 0) + currentScore;
                
                // Сохраняем обновленные данные
                localStorage.setItem('raccoonClickerShared', JSON.stringify(savedData));
                
                // Перенаправляем на страницу menu.html
                window.location.href = 'gamess.html';
            }

            // Константы игры
            const COLS = 10;
            const ROWS = 10;
            const BLOCK_SIZE = 30;

            // Элементы DOM
            const gameBoard = document.getElementById('game-board');
            const scoreElement = document.getElementById('score');
            const gameOverElement = document.getElementById('game-over');
            const finalScoreElement = document.getElementById('final-score');
            const restartBtn = document.getElementById('restart-btn');
            const preview1 = document.getElementById('preview-1');
            const preview2 = document.getElementById('preview-2');
            const preview3 = document.getElementById('preview-3');

            // Состояние игры
            let board = createBoard();
            let score = 0;
            let gameOver = false;
            let previewPieces = [];
            let activeDragPiece = null;
            let dragStartElement = null;
            let hoverHighlight = null;

            // Фигуры Тетриса
            const SHAPES = {
                I: {
                    shape: [
                        [0, 0, 0, 0],
                        [1, 1, 1, 1],
                        [0, 0, 0, 0],
                        [0, 0, 0, 0]
                    ],
                    color: 'I',
                    variants: ['I-1', 'I-2', 'I-3']
                },
                J: {
                    shape: [
                        [1, 0, 0],
                        [1, 1, 1],
                        [0, 0, 0]
                    ],
                    color: 'J',
                    variants: ['J-1', 'J-2', 'J-3']
                },
                L: {
                    shape: [
                        [0, 0, 1],
                        [1, 1, 1],
                        [0, 0, 0]
                    ],
                    color: 'L',
                    variants: ['L-1', 'L-2', 'L-3']
                },
                O: {
                    shape: [
                        [1, 1],
                        [1, 1]
                    ],
                    color: 'O',
                    variants: ['O-1', 'O-2', 'O-3']
                },
                S: {
                    shape: [
                        [0, 1, 1],
                        [1, 1, 0],
                        [0, 0, 0]
                    ],
                    color: 'S',
                    variants: ['S-1', 'S-2', 'S-3']
                },
                T: {
                    shape: [
                        [0, 1, 0],
                        [1, 1, 1],
                        [0, 0, 0]
                    ],
                    color: 'T',
                    variants: ['T-1', 'T-2', 'T-3']
                },
                Z: {
                    shape: [
                        [1, 1, 0],
                        [0, 1, 1],
                        [0, 0, 0]
                    ],
                    color: 'Z',
                    variants: ['Z-1', 'Z-2', 'Z-3']
                }
            };

            // Случайная фигура
            function randomPiece() {
                const keys = Object.keys(SHAPES);
                const randomKey = keys[Math.floor(Math.random() * keys.length)];
                const piece = Object.assign({}, SHAPES[randomKey]);

                // Для каждого блока в фигуре выбираем случайный вариант цвета
                const shapeWithColors = piece.shape.map(row => 
                    row.map(cell => cell ? piece.variants[Math.floor(Math.random() * piece.variants.length)] : 0)
                );

                return {
                    shape: piece.shape,
                    color: piece.color,
                    shapeWithColors: shapeWithColors,
                    variants: piece.variants
                };
            }

            // Создание игрового поля
            function createBoard() {
                return Array.from({length: ROWS}, () => Array(COLS).fill(0));
            }

            // Рисование игрового поля
            function drawBoard() {
                // Очищаем игровое поле
                gameBoard.innerHTML = '';

                // Рисуем сетку
                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLS; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        cell.style.width = `${BLOCK_SIZE}px`;
                        cell.style.height = `${BLOCK_SIZE}px`;
                        cell.style.left = `${x * BLOCK_SIZE}px`;
                        cell.style.top = `${y * BLOCK_SIZE}px`;
                        gameBoard.appendChild(cell);
                    }
                }

                // Рисуем только новые блоки с анимацией
                const existingBlocks = Array.from(gameBoard.querySelectorAll('.block'))
                    .map(b => `${b.style.left}_${b.style.top}`);

                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLS; x++) {
                        if (board[y][x]) {
                            const blockKey = `${x * BLOCK_SIZE}px_${y * BLOCK_SIZE}px`;
                            if (!existingBlocks.includes(blockKey)) {
                                const block = document.createElement('div');
                                block.className = `block ${board[y][x]} landing`;
                                block.style.width = `${BLOCK_SIZE}px`;
                                block.style.height = `${BLOCK_SIZE}px`;
                                block.style.left = `${x * BLOCK_SIZE}px`;
                                block.style.top = `${y * BLOCK_SIZE}px`;
                                gameBoard.appendChild(block);
                            }
                        }
                    }
                }
            }

            // Рисование превью фигур
            function drawPreviewPieces() {
                preview1.innerHTML = '';
                preview2.innerHTML = '';
                preview3.innerHTML = '';

                // Добавляем кнопки вращения
                previewPieces.forEach((piece, index) => {
                    const previewContainer = [preview1, preview2, preview3][index];
                    previewContainer.className = 'preview-piece';

                    const previewWidth = previewContainer.offsetWidth;
                    const previewHeight = previewContainer.offsetHeight;

                    // Центрируем фигуру в превью
                    const offsetX = (previewWidth - piece.shape[0].length * BLOCK_SIZE) / 2;
                    const offsetY = (previewHeight - piece.shape.length * BLOCK_SIZE) / 2;

                    for (let y = 0; y < piece.shape.length; y++) {
                        for (let x = 0; x < piece.shape[y].length; x++) {
                            if (piece.shape[y][x]) {
                                const block = document.createElement('div');
                                const variant = piece.shapeWithColors[y][x];
                                block.className = `block ${variant}`;
                                block.style.width = `${BLOCK_SIZE}px`;
                                block.style.height = `${BLOCK_SIZE}px`;
                                block.style.left = `${offsetX + x * BLOCK_SIZE}px`;
                                block.style.top = `${offsetY + y * BLOCK_SIZE}px`;
                                block.style.animationDelay = `${(x + y) * 0.08}s`;
                                block.dataset.pieceIndex = index;
                                block.dataset.blockX = x;
                                block.dataset.blockY = y;
                                previewContainer.appendChild(block);
                            }
                        }
                    }

                    // Добавляем кнопку вращения
                    const rotateBtn = document.createElement('button');
                    rotateBtn.className = 'rotate-btn';
                    rotateBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
                    rotateBtn.dataset.pieceIndex = index;
                    rotateBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        rotatePreviewPiece(parseInt(this.dataset.pieceIndex));
                    });
                    previewContainer.appendChild(rotateBtn);
                });

                // Заполняем пустые превью
                for (let i = previewPieces.length; i < 3; i++) {
                    const previewContainer = [preview1, preview2, preview3][i];
                    previewContainer.className = 'preview-piece empty';
                }

                // Обновляем обработчики событий для перетаскивания
                setupDragAndDrop();
            }

            // Проверка столкновений
            function collision(x, y, shape) {
                for (let row = 0; row < shape.length; row++) {
                    for (let col = 0; col < shape[row].length; col++) {
                        if (!shape[row][col]) continue;

                        const newX = x + col;
                        const newY = y + row;

                        if (
                            newX < 0 || 
                            newX >= COLS || 
                            newY >= ROWS ||
                            (newY >= 0 && board[newY][newX])
                        ) {
                            return true;
                        }
                    }
                }
                return false;
            }

            // Проверка заполненных линий
            function checkLines() {
                const linesToClear = [];

                // Находим заполненные линии
                for (let y = ROWS - 1; y >= 0; y--) {
                    if (board[y].every(cell => cell !== 0)) {
                        linesToClear.push(y);
                    }
                }

                if (linesToClear.length > 0) {
                    // Анимация удаления линий
                    animateLineClear(linesToClear);

                    // Удаляем линии и добавляем очки
                    clearLines(linesToClear);
                }
            }

            // Анимация удаления линий
            function animateLineClear(lines) {
                lines.forEach(y => {
                    for (let x = 0; x < COLS; x++) {
                        const lineClear = document.createElement('div');
                        lineClear.className = 'line-clear';
                        lineClear.style.width = `${BLOCK_SIZE}px`;
                        lineClear.style.height = `${BLOCK_SIZE}px`;
                        lineClear.style.left = `${x * BLOCK_SIZE}px`;
                        lineClear.style.top = `${y * BLOCK_SIZE}px`;
                        gameBoard.appendChild(lineClear);
                    }
                });
            }

            // Удаление линий и добавление очков
            function clearLines(lines) {
                // Сортируем линии сверху вниз
                lines.sort((a, b) => a - b);

                // Добавляем очки в зависимости от количества собранных линий
                const linePoints = [0, 200, 1000, 3000, 5200]; // Очки за 0, 1, 2, 3, 4 линии
                const points = linePoints[lines.length];
                score += points;
                scoreElement.textContent = score;

                // Удаляем линии и сдвигаем остальные вниз
                for (const line of lines) {
                    board.splice(line, 1);
                    board.unshift(Array(COLS).fill(0));
                }

                drawBoard();
            }

            // Создание новых фигур для превью
            function createPreviewPieces() {
                previewPieces = [
                    randomPiece(),
                    randomPiece(),
                    randomPiece()
                ];
                drawPreviewPieces();
            }

            // Поворот фигуры в превью
            function rotatePreviewPiece(index) {
                if (index >= previewPieces.length) return;

                const originalShape = previewPieces[index].shape;
                const originalColors = previewPieces[index].shapeWithColors;
                const rows = originalShape.length;
                const cols = originalShape[0].length;

                // Создаем новую повернутую матрицу
                const rotatedShape = Array.from({length: cols}, () => Array(rows).fill(0));
                const rotatedColors = Array.from({length: cols}, () => Array(rows).fill(0));

                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        rotatedShape[x][rows - 1 - y] = originalShape[y][x];
                        rotatedColors[x][rows - 1 - y] = originalColors[y][x];
                    }
                }

                previewPieces[index].shape = rotatedShape;
                previewPieces[index].shapeWithColors = rotatedColors;
                drawPreviewPieces();
            }

            // Показ экрана окончания игры с анимацией
            function showGameOver() {
                finalScoreElement.textContent = score;
                
                // Добавляем класс corrupted всем блокам
                const blocks = document.querySelectorAll('.block');
                let delay = 0;
                
                blocks.forEach((block, index) => {
                    // Случайно выбираем анимацию для каждого блока
                    delay = Math.random() * 0.8;
                    setTimeout(() => {
                        block.classList.add('corrupted');
                    }, delay * 1000);
                    
                    // Добавляем дополнительное мерцание для некоторых блоков
                    if (Math.random() > 0.7) {
                        block.style.animation += `, flicker ${Math.random() * 0.5 + 0.5}s ease infinite`;
                    }
                });
                
                // Показываем экран проигрыша после анимации падения
                setTimeout(() => {
                    gameOverElement.classList.add('show');
                }, 800);
            }

            // Скрытие экрана окончания игры
            function hideGameOver() {
                gameOverElement.classList.remove('show');
            }

            // Начало новой игры
            function startGame() {
                // Сброс состояния игры
                board = createBoard();
                score = 0;
                gameOver = false;

                scoreElement.textContent = score;

                hideGameOver();

                // Создаем превью фигур
                createPreviewPieces();

                drawBoard();
            }
            
            // Проверка конца игры
            function checkGameOver() {
                // Проверяем, есть ли блоки в верхней строке
                for (let x = 0; x < COLS; x++) {
                    if (board[0][x] !== 0) {
                        gameOver = true;
                        showGameOver();
                        return true;
                    }
                }
                return false;
            }
            
            // Обработчики событий для перетаскивания фигур
            function setupDragAndDrop() {
                const previewBlocks = document.querySelectorAll('.preview-piece .block');
                
                previewBlocks.forEach(block => {
                    // Удаляем старые обработчики, если они есть
                    block.removeEventListener('mousedown', startDrag);
                    block.removeEventListener('touchstart', startDrag);
                    
                    // Добавляем новые обработчики
                    block.addEventListener('mousedown', startDrag);
                    block.addEventListener('touchstart', startDrag, { passive: false });
                });
                
                // Удаляем старые обработчики, если они есть
                document.removeEventListener('mousemove', dragPiece);
                document.removeEventListener('touchmove', dragPiece);
                document.removeEventListener('mouseup', endDrag);
                document.removeEventListener('touchend', endDrag);
                
                // Добавляем новые обработчики
                document.addEventListener('mousemove', dragPiece);
                document.addEventListener('touchmove', dragPiece, { passive: false });
                document.addEventListener('mouseup', endDrag);
                document.addEventListener('touchend', endDrag);
            }
            
            function startDrag(e) {
    if (gameOver) return;

    e.preventDefault();

    const pieceIndex = parseInt(e.target.dataset.pieceIndex);
    const blockX = parseInt(e.target.dataset.blockX);
    const blockY = parseInt(e.target.dataset.blockY);

    if (pieceIndex >= previewPieces.length) return;

    // Запоминаем элемент, с которого начали перетаскивание
    dragStartElement = e.target.closest('.preview-piece');
    dragStartElement.classList.add('dragging-source');

    // Создаем копию фигуры для перетаскивания
    activeDragPiece = {
        ...previewPieces[pieceIndex],
        pieceIndex: pieceIndex,
        dragX: e.clientX || e.touches[0].clientX,
        dragY: e.clientY || e.touches[0].clientY,
        offsetX: blockX * BLOCK_SIZE,
        offsetY: blockY * BLOCK_SIZE,
        selectedBlockX: blockX,  // добавлено
        selectedBlockY: blockY   // добавлено
    };

    // Добавляем класс для визуального эффекта
    e.target.classList.add('dragging');

    // Создаем визуальное представление перетаскиваемой фигуры
    const dragVisual = document.createElement('div');
    dragVisual.id = 'drag-visual';
    document.body.appendChild(dragVisual);

    for (let y = 0; y < activeDragPiece.shape.length; y++) {
        for (let x = 0; x < activeDragPiece.shape[y].length; x++) {
            if (activeDragPiece.shape[y][x]) {
                const block = document.createElement('div');
                const variant = activeDragPiece.shapeWithColors[y][x];
                block.className = `block ${variant}`;
                block.style.width = `${BLOCK_SIZE}px`;
                block.style.height = `${BLOCK_SIZE}px`;
                block.style.left = `${x * BLOCK_SIZE}px`;
                block.style.top = `${y * BLOCK_SIZE}px`;
                dragVisual.appendChild(block);
            }
        }
    }

    // Создаем подсветку для предпросмотра позиции
    hoverHighlight = document.createElement('div');
    hoverHighlight.className = 'hover-highlight';
    hoverHighlight.style.width = `${activeDragPiece.shape[0].length * BLOCK_SIZE}px`;
    hoverHighlight.style.height = `${activeDragPiece.shape.length * BLOCK_SIZE}px`;
    gameBoard.appendChild(hoverHighlight);

    // Обновляем позицию сразу
    updateDragPosition(e);
}

            
            function dragPiece(e) {
                if (!activeDragPiece) return;
                
                e.preventDefault();
                updateDragPosition(e);
            }
            
            function updateDragPosition(e) {
                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                
                // Обновляем позицию визуального элемента
                const dragVisual = document.getElementById('drag-visual');
                if (dragVisual) {
                    dragVisual.style.left = `${clientX}px`;
                    dragVisual.style.top = `${clientY}px`;
                }
                
                // Обновляем подсветку позиции на игровом поле
                if (hoverHighlight) {
                    const rect = gameBoard.getBoundingClientRect();

const pixelX = clientX - rect.left;
const pixelY = clientY - rect.top;

const snappedX = Math.round(pixelX / BLOCK_SIZE);
const snappedY = Math.round(pixelY / BLOCK_SIZE);

// Проверка, влезает ли вся фигура на поле
if (
    snappedX >= 0 &&
    snappedY >= 0 &&
    snappedX + activeDragPiece.shape[0].length <= COLS &&
    snappedY + activeDragPiece.shape.length <= ROWS
) {
    hoverHighlight.style.left = `${snappedX * BLOCK_SIZE}px`;
    hoverHighlight.style.top = `${snappedY * BLOCK_SIZE}px`;
    hoverHighlight.style.display = 'block';
} else {
    hoverHighlight.style.display = 'none';
}

                }
            }
            
              function endDrag(e) {
    if (!activeDragPiece) return;

    e.preventDefault();

    // Удаляем визуальный элемент
    const dragVisual = document.getElementById('drag-visual');
if (!dragVisual) return;

const visualRect = dragVisual.getBoundingClientRect(); // сначала получаем позицию
dragVisual.remove(); // только потом удаляем элемент


    // Удаляем подсветку
    if (hoverHighlight) {
        hoverHighlight.remove();
        hoverHighlight = null;
    }

    // Удаляем класс dragging
    const draggingBlocks = document.querySelectorAll('.block.dragging');
    draggingBlocks.forEach(block => block.classList.remove('dragging'));

    // Удаляем класс dragging-source
    if (dragStartElement) {
        dragStartElement.classList.remove('dragging-source');
        dragStartElement = null;
    }

    // Получаем левый верхний угол фигуры через DOM
    const boardRect = gameBoard.getBoundingClientRect();
    if (!visualRect) return;

    const offsetX = visualRect.left - boardRect.left;
    const offsetY = visualRect.top - boardRect.top;

    const snappedX = Math.round(offsetX / BLOCK_SIZE);
    const snappedY = Math.round(offsetY / BLOCK_SIZE);

    // Проверка, помещается ли фигура в этом месте
    if (!collision(snappedX, snappedY, activeDragPiece.shape)) {
        for (let y = 0; y < activeDragPiece.shape.length; y++) {
            for (let x = 0; x < activeDragPiece.shape[y].length; x++) {
                if (activeDragPiece.shape[y][x]) {
                    const newY = snappedY + y;
                    const newX = snappedX + x;

                    if (newY >= 0 && newY < ROWS && newX >= 0 && newX < COLS) {
                        board[newY][newX] = activeDragPiece.shapeWithColors[y][x];
                    }
                }
            }
        }

        // Удаляем использованную фигуру из превью
        previewPieces.splice(activeDragPiece.pieceIndex, 1);

        // Проверяем линии
        checkLines();

        // Проверяем конец игры
        if (!checkGameOver()) {
            // Если превью пустые, создаем новые фигуры
            if (previewPieces.length === 0) {
                createPreviewPieces();
            } else {
                drawPreviewPieces();
            }

            drawBoard();
        }
    }

    activeDragPiece = null;
}


            
            restartBtn.addEventListener('click', startGame);
            
            // Добавляем класс для отслеживания первого запуска
            let isFirstLoad = true;
            
            function startGame(isInitial = false) {
                // Если это первый запуск, добавляем класс для анимации
                if (isInitial) {
                    document.querySelector('.game-container').classList.add('initial-load');
                } else {
                    document.querySelector('.game-container').classList.remove('initial-load');
                }
                
                // Сброс состояния игры
                board = createBoard();
                score = 0;
                gameOver = false;

                scoreElement.textContent = score;

                hideGameOver();

                // Создаем превью фигур
                createPreviewPieces();

                drawBoard();
            }
            
            // Начинаем игру (первый запуск)
            startGame(true);
        });
    </script>
</body>
</html>